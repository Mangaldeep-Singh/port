<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://zhaospei.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://zhaospei.github.io//" rel="alternate" type="text/html" /><updated>2023-06-18T16:27:26+07:00</updated><id>https://zhaospei.github.io//feed.xml</id><title type="html">Tuan-Dung Bui</title><subtitle>A markdown blog made by Tuan-Dung Bui aka Zhao (zhaospei). Hosted on zhaospei.github.io. I'll write something i like maybe my study or life.</subtitle><author><name>Tuan-Dung Bui</name></author><entry><title type="html">Kiểm thử bằng phương pháp phân tích giá trị biên</title><link href="https://zhaospei.github.io//testing/2023/05/13/kiem-thu-gia-tri-bien/" rel="alternate" type="text/html" title="Kiểm thử bằng phương pháp phân tích giá trị biên" /><published>2023-05-13T00:00:00+07:00</published><updated>2023-05-13T00:00:00+07:00</updated><id>https://zhaospei.github.io//testing/2023/05/13/kiem-thu-gia-tri-bien</id><content type="html" xml:base="https://zhaospei.github.io//testing/2023/05/13/kiem-thu-gia-tri-bien/"><![CDATA[<p>Trong quá trình phát triển phần mềm, kiểm thử là một bước không thể thiếu để đảm bảo chất lượng và độ tin cậy của sản phẩm. Trong số các phương pháp kiểm thử, kiểm thử phân tích giá trị biên (Boundary Value Analysis) đã được đánh giá cao vì tính hiệu quả và độ chính xác của nó. Phương pháp này giúp tập trung kiểm thử vào các giá trị biên của dữ liệu đầu vào, từ đó giảm thiểu thời gian và chi phí kiểm thử.</p>

<p>Bài viết này sẽ cách sinh test cho ca kiểm thử phân tích giá trị biên thông qua một bài toán kiểm thử nhỏ.</p>

<h1 id="bài-toán">Bài toán</h1>

<p><strong>DummyTel</strong> có cấu trúc tỷ lệ sau đây cho các cuộc gọi đường dài:</p>

<ul>
  <li>Bất kỳ cuộc gọi nào bắt đầu lúc hoặc sau 18:00 nhưng trước 08:00 được giảm 50%.</li>
  <li>Bất kỳ cuộc gọi nào bắt đầu lúc hoặc sau 08:00 nhưng trước 18:00 được tính giá đầy đủ.</li>
  <li>Bất kỳ cuộc gọi nào dài hơn 60 phút đều được giảm giá 15% trên chi phí (sau khi trừ đi bất kỳ khoản giảm giá nào khác).</li>
</ul>

<p>Chương trình đọc <strong>thời điểm bắt đầu cuộc gọi</strong> dựa trên đồng hồ 24 giờ và <strong>thời lượng của cuộc gọi</strong>. Thời gian cuộc gọi tối đa là 180 phút.</p>

<p>Chương trả về:</p>
<ul>
  <li>-1 nếu đầu vào không hợp lệ.</li>
  <li>0  nếu không được giảm giá.</li>
  <li>1  nếu được giảm 15%.</li>
  <li>2  nếu được giảm 50%.</li>
  <li>3  nếu vừa được giảm 50% và 15%.</li>
</ul>

<p>Chương trình sẽ giả sử chỉ các giá trị số nguyên được nhập vào, thời lượng không âm và thời gian bắt đầu biểu thị thời gian đồng hồ thực.</p>

<h1 id="phân-tích-yêu-cầu">Phân tích yêu cầu</h1>

<p>Đầu vào của chương trình: Thời điểm bắt đầu, Thời lượng của cuộc gọi. 
Đầu ra của chường trình: Chi phí của cuộc gọi 
Điều kiện hợp lệ của đầu vào:</p>
<ul>
  <li>Thời điểm bắt đầu: Có giá trị nguyên trong khoảng từ 0 đến 23.</li>
  <li>Thời lượng cuộc gọi: Từ 0 đến 180.
Giá trị đầu ra: 0 (nếu không được giảm giá), 1 (nếu được giảm 15%), 2 (nếu được giảm 50%), 3 (nếu vừa được giảm 50% và 15%).</li>
</ul>

<h1 id="phân-vùng-tương-đương">Phân vùng tương đương</h1>
<p>Ta chia thành các giá trị đầu vào thành các phân vùng tương đương sau:</p>

<p>Gọi <strong>TĐBB</strong> là Thời điểm bắt đầu cuộc gọi, <strong>TLCG</strong> là Thời lượng cuộc gọi.</p>

<table>
  <thead>
    <tr>
      <th>TH</th>
      <th>Inputs</th>
      <th>Output</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>TĐBB ∉{0,…,23} hoặc TGCG ∉{0,…,180}</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Hợp lệ và (8 &lt;= TĐBB &lt; 18 và TGCG &lt;= 60)</td>
      <td>0</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Hợp lệ và (8 &lt;= TĐBB &lt; 18 và TGCG &gt; 60)</td>
      <td>1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Hợp lệ và (TGCG &lt;= 60 và (TĐBB &gt;= 18 hoặc TĐBB &lt; 8))</td>
      <td>2</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Các TH còn lại</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>Từ bảng trên ta sinh 5 test cho 5 phần vùng tương đương lần lượt là:</p>

<table>
  <thead>
    <tr>
      <th>Testcase</th>
      <th>Inputs</th>
      <th>EO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>TĐBB = -2 và TGCG = 191</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>TĐBB = 12 và TGCG = 45</td>
      <td>0</td>
    </tr>
    <tr>
      <td>3</td>
      <td>TĐBB = 14 và TGCG = 92</td>
      <td>1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>TĐBB = 20 và TGCG = 30</td>
      <td>2</td>
    </tr>
    <tr>
      <td>5</td>
      <td>TĐBB = 21 và TGCG = 124</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<h1 id="xác-định-biên">Xác định biên</h1>

<p><strong>Biên của TĐBB:</strong></p>

<p><img src="/assets/media/post/bien-1.png" alt="Biên của TĐBB" /></p>

<ul>
  <li>Giá trị biên của TĐBB lần lượt là 0, 8, 18, 23</li>
  <li>Giá trị nom của TĐBB là 12 (Điểm giữa của miền hợp lệ)</li>
</ul>

<p><strong>Biên của TGCG:</strong></p>

<p><img src="/assets/media/post/bien-2.png" alt="Biên của TĐBB" /></p>

<ul>
  <li>Giá trị biên của TGCG lần lượt là 0, 60, 180</li>
  <li>Giá trị nom của TGCG là 90 (Điểm giữa của miền hợp lệ)</li>
</ul>

<h1 id="sinh-test-cho-kiểm-thử-biên-đơn-giản">Sinh test cho kiểm thử biên đơn giản</h1>
<p>Mỗi giá trị biên của một input kết hợp với các giá trị nom của các input còn lại và một test bao gồm tất cả các giá trị nom của các input.</p>

<p>Hay chúng ta có tổng cộng: 4 + 3 + 1 = 8 (Testcases)</p>

<table>
  <thead>
    <tr>
      <th>Testcase</th>
      <th>Inputs</th>
      <th>EO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>TĐBB = 0 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>2</td>
      <td>TĐBB = 8 và TGCG = 90</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3</td>
      <td>TĐBB = 18 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>4</td>
      <td>TĐBB = 23 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>5</td>
      <td>TĐBB = 12 và TGCG = 0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>6</td>
      <td>TĐBB = 12 và TGCG = 60</td>
      <td>0</td>
    </tr>
    <tr>
      <td>7</td>
      <td>TĐBB = 12 và TGCG = 180</td>
      <td>1</td>
    </tr>
    <tr>
      <td>8</td>
      <td>TĐBB = 12 và TGCG = 90</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<h1 id="biên-và-cận-biên-trong-miền-hợp-lệ">Biên và cận biên trong miền hợp lệ</h1>
<p>Các test case tương tự như biên đơn giản và thêm các test case cận biên bằng cách kết hợp giá trị cận biên của một input với các giá trị nom của các input còn lại.</p>

<p>Lấy các giá trị cận biên cách giá trị biên một khoảng là 1.</p>

<p>TĐBB có 4 giá trị biên -&gt; 6 giá trị cận biên trong miền hợp lệ.</p>

<p>TGCG có 3 giá trị biên -&gt; 4 giá trị cận biên trong miền hợp lệ.</p>

<p>Vậy số test cases tất cả là 8 + 6 + 4 = 18 (Testcase)</p>

<table>
  <thead>
    <tr>
      <th>Testcase</th>
      <th>Inputs</th>
      <th>EO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>TĐBB = 0 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>2</td>
      <td>TĐBB = 8 và TGCG = 90</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3</td>
      <td>TĐBB = 18 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>4</td>
      <td>TĐBB = 23 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>5</td>
      <td>TĐBB = 12 và TGCG = 0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>6</td>
      <td>TĐBB = 12 và TGCG = 60</td>
      <td>0</td>
    </tr>
    <tr>
      <td>7</td>
      <td>TĐBB = 12 và TGCG = 180</td>
      <td>1</td>
    </tr>
    <tr>
      <td>8</td>
      <td>TĐBB = 12 và TGCG = 90</td>
      <td>1</td>
    </tr>
    <tr>
      <td>9</td>
      <td>TĐBB = 1 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>10</td>
      <td>TĐBB = 7 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>11</td>
      <td>TĐBB = 9 và TGCG = 90</td>
      <td>1</td>
    </tr>
    <tr>
      <td>12</td>
      <td>TĐBB = 17 và TGCG = 90</td>
      <td>1</td>
    </tr>
    <tr>
      <td>13</td>
      <td>TĐBB = 19 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>14</td>
      <td>TĐBB = 22 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>15</td>
      <td>TĐBB = 12 và TGCG = 1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>16</td>
      <td>TĐBB = 12 và TGCG = 59</td>
      <td>0</td>
    </tr>
    <tr>
      <td>17</td>
      <td>TĐBB = 12 và TGCG = 61</td>
      <td>1</td>
    </tr>
    <tr>
      <td>18</td>
      <td>TĐBB = 12 và TGCG = 179</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<h1 id="biên-và-cận-biên-trong-toàn-bộ-miền-giá-trị">Biên và cận biên trong toàn bộ miền giá trị.</h1>
<p>Các test case tương tự như biên và cận biên trong miền hợp lệ và thêm các test case cận biên ngoài miền hợp lệ bằng cách kết hợp giá trị cận biên ngoài miền hợp lệ của một input với các giá trị nom của các input còn lại.</p>

<p>Lấy các giá trị cận biên cách giá trị biên một khoảng là 1.</p>

<p>Nhận thấy:</p>
<ul>
  <li>TĐBB có 2 giá trị cận biên ngoài miền hợp lệ.</li>
  <li>TGCG có 2 giá trị cận biên ngoài miền hợp lệ.</li>
</ul>

<p>Vậy số test cases tất cả là 18 + 2 + 2 = 22 (Testcase)</p>

<table>
  <thead>
    <tr>
      <th>Testcase</th>
      <th>Inputs</th>
      <th>EO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>TĐBB = 0 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>2</td>
      <td>TĐBB = 8 và TGCG = 90</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3</td>
      <td>TĐBB = 18 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>4</td>
      <td>TĐBB = 23 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>5</td>
      <td>TĐBB = 12 và TGCG = 0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>6</td>
      <td>TĐBB = 12 và TGCG = 60</td>
      <td>0</td>
    </tr>
    <tr>
      <td>7</td>
      <td>TĐBB = 12 và TGCG = 180</td>
      <td>1</td>
    </tr>
    <tr>
      <td>8</td>
      <td>TĐBB = 12 và TGCG = 90</td>
      <td>1</td>
    </tr>
    <tr>
      <td>9</td>
      <td>TĐBB = 1 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>10</td>
      <td>TĐBB = 7 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>11</td>
      <td>TĐBB = 9 và TGCG = 90</td>
      <td>1</td>
    </tr>
    <tr>
      <td>12</td>
      <td>TĐBB = 17 và TGCG = 90</td>
      <td>1</td>
    </tr>
    <tr>
      <td>13</td>
      <td>TĐBB = 19 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>14</td>
      <td>TĐBB = 22 và TGCG = 90</td>
      <td>3</td>
    </tr>
    <tr>
      <td>15</td>
      <td>TĐBB = 12 và TGCG = 1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>16</td>
      <td>TĐBB = 12 và TGCG = 59</td>
      <td>0</td>
    </tr>
    <tr>
      <td>17</td>
      <td>TĐBB = 12 và TGCG = 61</td>
      <td>1</td>
    </tr>
    <tr>
      <td>18</td>
      <td>TĐBB = 12 và TGCG = 179</td>
      <td>1</td>
    </tr>
    <tr>
      <td>19</td>
      <td>TĐBB = 12 và TGCG = -1</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>20</td>
      <td>TĐBB = 12 và TGCG = 181</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>21</td>
      <td>TĐBB = -1 và TGCG = 90</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>22</td>
      <td>TĐBB = 24 và TGCG = 90</td>
      <td>-1</td>
    </tr>
  </tbody>
</table>

<h1 id="kết-luận">Kết luận</h1>
<p>Nhận thấy toàn bộ test case trong kiểm thử giá trị biên trên đều không cho output nằm trong trường hợp số 2. Vì vậy, kiểm thử giá trị biên sẽ không thể bao hàm toàn bộ trường hợp và thường kết hợp với các loại kiểm thử khác như phân hoạch tương đương hoặc kiểm thử bằng quyết định,.. 
Thường trong thực tế, các công ty thường sinh test kiểu này: Kết hợp phân hoạch tương đương (hoặc bảng quyết định) với phân tích giá trị biên thường cho kết quả tốt vì nó có chi phí, thời gian, công sức vừa phải và bao hàm hầu hết mọi trường hợp của giá trị đầu vào.</p>]]></content><author><name>zhao</name></author><category term="Testing" /><category term="testing" /><summary type="html"><![CDATA[Trong quá trình phát triển phần mềm, kiểm thử là một bước không thể thiếu để đảm bảo chất lượng và độ tin cậy của sản phẩm. Trong số các phương pháp kiểm thử, kiểm thử phân tích giá trị biên (Boundary Value Analysis) đã được đánh giá cao vì tính hiệu quả và độ chính xác của nó. Phương pháp này giúp tập trung kiểm thử vào các giá trị biên của dữ liệu đầu vào, từ đó giảm thiểu thời gian và chi phí kiểm thử.]]></summary></entry><entry><title type="html">Từ nơ-ron sinh học đến nơ-ron nhân tạo</title><link href="https://zhaospei.github.io//deep-learning/2023/05/13/tu-noron-sinh-hoc-den-noron-nhan-tao/" rel="alternate" type="text/html" title="Từ nơ-ron sinh học đến nơ-ron nhân tạo" /><published>2023-05-13T00:00:00+07:00</published><updated>2023-05-13T00:00:00+07:00</updated><id>https://zhaospei.github.io//deep-learning/2023/05/13/tu-noron-sinh-hoc-den-noron-nhan-tao</id><content type="html" xml:base="https://zhaospei.github.io//deep-learning/2023/05/13/tu-noron-sinh-hoc-den-noron-nhan-tao/"><![CDATA[<p>Bài viết sẽ được viết trong khoảng thời gian sớm nhất bởi kẻ tập viết blog tập sự tại Zhao - @Tuan-Dung Bui. Bài viết sẽ mở đầu cho chương về học máy của tác giả, đồng thời chương về công nghệ phần mềm sẽ tạm thời ngừng viết.</p>]]></content><author><name>zhao</name></author><category term="Deep-Learning" /><category term="neuron" /><category term="deep-learning" /><summary type="html"><![CDATA[Bài viết sẽ được viết trong khoảng thời gian sớm nhất bởi kẻ tập viết blog tập sự tại Zhao - @Tuan-Dung Bui. Bài viết sẽ mở đầu cho chương về học máy của tác giả, đồng thời chương về công nghệ phần mềm sẽ tạm thời ngừng viết.]]></summary></entry><entry><title type="html">Điểm mạnh/yếu công cụ kiểm thử chịu tải tự động k6 với các đối thủ</title><link href="https://zhaospei.github.io//testing/2023/05/01/k6-vs-jmeter/" rel="alternate" type="text/html" title="Điểm mạnh/yếu công cụ kiểm thử chịu tải tự động k6 với các đối thủ" /><published>2023-05-01T00:00:00+07:00</published><updated>2023-05-01T00:00:00+07:00</updated><id>https://zhaospei.github.io//testing/2023/05/01/k6-vs-jmeter</id><content type="html" xml:base="https://zhaospei.github.io//testing/2023/05/01/k6-vs-jmeter/"><![CDATA[<p>Các công cụ kiểm thử tải (Load Testing Tool - LTT) đã trở nên rất phổ biến hiện nay, cả miễn phí và có phí, nguồn mở và nguồn đóng, và mỗi công cụ đều có điểm mạnh và yếu của riêng mình. Một số LTT được nhiều nhà phát triển sử dụng, có thể kể đến công cụ miễn phí như JMeter, Locus, fortio,… hay có tính phí như LoadNinja, Gatling,…  Và Grafana k6 (hay k6) là một trong số ấy.</p>

<p>Được phát triển bới Grafana Labs, k6 là một LTT mã nguồn mở giúp kiểm tra hiệu suất dễ dàng và hiệu quả cho các nhà phát triển. Nó là công cụ mã nguồn mở, hướng đến nhà phát triển và dễ dàng mở rộng. Dù chỉ mới ra đời gần đây, bản release chính thức đầu tiên trên github vào ngày 27/02/2017, nhưng k6 đã nhanh chóng nổi lên trong cộng đồng nhà phát triển bởi hiệu suất và tính dễ sử dụng đáng bất ngờ của nó.  Tính đến thời điểm hiện tại (04/2023), k6 có 20.1k stars, 311 watching và 1.1k forks trên github. Nhờ cộng đồng phát triển hoạt động tích cực, k6 đang phát triển ngày càng lớn mạnh. Kho extensions phong phú, pull request và những bản releases thường xuyên là những lợi ích mà mã nguồn mở của k6 mang lại.</p>

<p>Phần so sánh với các công cụ dưới đây không khẳng định công cụ nào là tốt hơn bởi vì không có điều kiện cụ thể nào để khẳng định công cụ nào là tốt nhất. Mọi thứ đều phụ thuộc vào vấn đề, tình huống mà nhóm phát triển đang gặp phải trả lời bởi các câu hỏi: cái gì (what), như thế nào (how), tại sao (why), khi nào (when) ca kiểm thử được thực hiện. Phần so sánh dưới đây của chúng tôi muốn trả lời ở đây là: “Mỗi công cụ vượt trội trong những tình huống nào?”.</p>

<p>Do hạn chế của bài viết nên tôi lựa chọn công cụ kiểm thử tự động đặc trưng nhất là Jmeter - công cụ kiểm thử ra đời sớm, được sử dụng rộng rãi. Mặc dù vậy, bằng việc so sánh với công cụ JMeter cũng để khát quát toàn bộ những tính năng nổi bật ở k6 và một số hạn chế còn gặp phải của nó.</p>

<p>JMeter[10] là một công cụ kiểm tra tải mã nguồn mở được xây dựng hoàn toàn bằng Java bởi Apache Foundation[11]. Nó được phát hành lần đầu tiên vào năm 1998 và nó đã tạo nên làn sóng vì sự táo bạo của nó trong việc sử dụng các công cụ kiểm tra chịu tải độc quyền nhưng biến nó thành miễn phí và trở nên phổ biến trong cộng đồng hơn. JMeter đã dùng thứ mà người dùng cần trả rất nhiều tiền để có thể sử dụng và phát hành nó công khai và miễn phí cho mọi người sử dụng. Mặc dù tập lệnh (scripts) cũng có thể được mở rộng bằng cách viết mã nhưng phần lớn tập lệnh trong JMeter được thực hiện bằng giao diện người dùng (GUI - Graphical User Interface). Tính đến thời điểm hiện tại (27/04/2023), phiên bản mới nhất của JMeter là 5.4.</p>

<h1 id="1-khi-nào-jmeter-nổi-bật-hơn">1. Khi nào Jmeter nổi bật hơn?</h1>

<h2 id="11-jmeter-có-giao-diện-người-dùng-gui---graphical-user-interface">1.1. Jmeter có giao diện người dùng (GUI - Graphical User Interface)</h2>
<p>Nếu bạn ở trong tình huống mà mọi người chưa từng thực hiện kiểm tra chịu tải trước đó và cần tìm hiểu một công cụ mới, thì một công cụ điều khiển bằng GUI như JMeter đơn giản là lựa chọn dễ dàng nhất. Tuy nhiên, màn hình kế hoạch kiểm tra (Test Plan) chào đón bạn khi bạn khởi động JMeter lần đầu tiên không cung cấp bất kỳ hướng dẫn nào về cách tạo trình lấy mẫu HTTP. UI là chủ quan ở một mức độ nhất định. Tuy nhiên, chúng tôi cho rằng việc khám phá giao diện người dùng dễ dàng hơn đối với những người không phải là nhà phát triển hơn là một chút sử dụng mã lệnh như k6.</p>

<p>k6 không có GUI được đóng gói trong công cụ, nhưng Trình tạo thử nghiệm k6(k6 Test Builder) có sẵn miễn phí. Đó là một cách để tạo các bài kiểm tra với giao diện GUI và mặc dù được đưa vào đám mây k6 nhưng nó không yêu cầu bất kỳ đăng ký nào để sử dụng. Tuy nhiên, nó không có đầy đủ tính năng như JMeter.</p>

<h2 id="12-jmeter-hỗ-trợ-nhiều-giao-thức-và-tính-năng-vượt-trội">1.2. JMeter hỗ trợ nhiều giao thức và tính năng vượt trội</h2>
<p>JMeter là công cụ kiểm thử tự động hỗ trợ nhiều giao thức nổi bật có thể kể đến như Web - HTTP, HTTPS (Java, NodeJS, PHP, ASP.NET, …), SOAP / REST Webservices, FTP, Database thông qua JDBC, Mail - SMTP(S), POP3(S) and IMAP(S), TCP, Java Objects, …
JMeter cũng có hầu hết các tính năng mà bạn sẽ cần cho một bài kiểm tra tải cơ bản và bạn không phải tự mình viết mã cho bất kỳ tính năng nào. Cấu trúc phần tử cha-con của nó có nghĩa là bạn có thể sửa đổi một phần tử cụ thể, chẳng hạn như yêu cầu HTTP hoặc sửa đổi tất cả các yêu cầu HTTP một cách dễ dàng như nhau. Thêm thời gian suy nghĩ cho tất cả các yêu cầu cũng dễ dàng như thêm Đồng hồ bấm giờ ngẫu nhiên thống nhất vào nhóm luồng của bạn và tất cả các yêu cầu trong nhóm đó sẽ kế thừa nó. Với các công cụ kiểm thử chịu tải dựa trên mã lệnh như k6, có thể khó tìm ra những gì có thể thực hiện được nếu không có giao diện người dùng.</p>

<h2 id="13-jmeter-có-cộng-đồng-người-dùng-kinh-nghiệm-với-nhiều-tài-liệu">1.3. JMeter có cộng đồng người dùng kinh nghiệm với nhiều tài liệu</h2>
<p>JMeter đã xuất hiện từ rất lâu và điều đó giúp nó có được một số điểm mạnh so với các cộng cụ mới ra đời như k6. JMeter đã xuất hiện từ năm 1998, vì vậy tính đến thời điểm này, nó đã có 22 năm để cải thiện và xây dựng cộng đồng người sử dụng. JMeter hiện diện trên gần như mọi trang mạng cộng đồng và cho dù trường hợp sử dụng JMeter của bạn cụ thể đến đâu, thì rất có thể nó đã được thực hiện trước đó. Tìm kiếm “cách tải bài kiểm tra X bằng JMeter” chắc chắn sẽ mang lại hàng nghìn lượt truy cập và một số video chỉ cho bạn chính xác cách thực hiện.</p>

<p>JMeter’s Component Reference[12]  là bằng chứng về tài liệu mở rộng và toàn diện của JMeter. Mọi phần tử, chức năng và thuộc tính đều được thảo luận chi tiết hơn hầu hết mọi người có thể mong muốn và đó chỉ là tài liệu chính thức trên trang web của Apache. Có hàng nghìn cuốn sách, hướng dẫn và khóa học về JMeter của những người dùng đam mê nó.</p>

<h2 id="14-jmeter-có-thể-thực-hiện-các-kiểm-thử-chịu-tải-phân-tán-với-chi-phí-hợp-lý">1.4. JMeter có thể thực hiện các kiểm thử chịu tải phân tán với chi phí hợp lý</h2>
<p>Một trong những tính năng tuyệt vời nhất của JMeter là nó cung cấp cho bạn một khung để chạy kiểm thử chịu tải phân tán với nó. Điều này khá đặc biệt đối với một công cụ mã nguồn mở và miễn phí.</p>

<p>Kiểm thử phân tán có nghĩa là tăng lượng tải bạn đang tạo bằng các kiểm thử chịu tải của mình, thường bằng cách tăng số lượng VU và chạy nhiều phiên bản tập lệnh của bạn trên các trình tạo chịu tải khác. JMeter thực hiện điều này bằng cách chỉ định một nút điều khiển và cho phép bạn thiết lập các nút worker. Mỗi nút worker cần có một bản sao của jmeter-server, một tiện ích đi kèm với mọi cài đặt JMeter (trong jmeter/bin).</p>

<p>k6 hỗ trợ chế độ kiểm thử chịu tải phân tán thông qua toán tử Kubernetes: Toán tử k6 cho phép bạn tạo đối tượng tài nguyên tùy chỉnh k6 trong cụm Kubernetes. Tuy nhiên, kiểm thử phân tán thông qua toán tử Kubernetes yêu cầu một mạng ổn định và tốc độ cao để đảm bảo rằng các nút kiểm thử có thể giao tiếp với nhau một cách hiệu quả. Nếu mạng không ổn định hoặc tốc độ mạng chậm, kiểm thử phân tán có thể gặp vấn đề về trễ hoặc thất bại.</p>

<h1 id="2-khi-nào-k6-nổi-bật-hơn">2. Khi nào k6 nổi bật hơn?</h1>
<h2 id="21-k6-có-thể-bắt-đầu-sử-dụng-nhanh-chóng">2.1. k6 có thể bắt đầu sử dụng nhanh chóng</h2>
<p>Bản thân JMeter khá dễ cài đặt, nhưng trước khi cài đặt JMeter, bạn cần cài đặt Java. Đặc biệt nếu bạn đang sử dụng Windows, thì người dùng JMeter mới sẽ gặp phải các vấn đề khi thêm các biến môi trường(environment variables) cần thiết để Java hoạt động. Cũng có thể gây nhầm lẫn khi xác định phiên bản Java nào là phiên bản phù hợp. Trong khi đó k6, có thể cài đặt dễ dàng thông qua một một câu lệnh trên terminal hay một gói cài đặt có sẵn.</p>

<p>Đối với JMeter, nơi mọi thứ đều là plugin… kể cả Trình quản lý plugin (Plugin Manager)! Hầu hết người dùng JMeter sẽ tranh luận rằng có một bộ plugin tiêu chuẩn mà bạn nên tải xuống trước khi bắt đầu sử dụng nó. Trong khi đó, tất cả các chức năng này đều có sẵn trong k6 ngay từ đầu.</p>

<h2 id="22-k6-có-thể-tối-đa-hiệu-suất-và-hiệu-quả-của-ca-kiểm-thử">2.2. k6 có thể tối đa hiệu suất và hiệu quả của ca kiểm thử</h2>
<p>k6 được viết bằng Go và Go được xây dựng có tính hiệu suất. Go là một ngôn ngữ được biên dịch và không cần phải thông dịch, không giống như Java hay Python. Không có lớp phức tạp nào được thêm vào.</p>

<p>Cách đơn giản và phổ biến nhất để công cụ kiểm thử chịu tải tạo VU là chỉ định một VU cho một nhân hoặc luồng (thread) hệ điều hành. Tuy nhiên, mô hình 1 luồng (thread): 1 VU có một lỗ hổng nghiêm trọng: khi VU đang chờ phản hồi hoặc thực hiện hàm sleep(), luồng cũng bị chặn và không thể xử lý công việc khác.</p>

<p>Trong k6, mỗi VU được chạy trên một goroutine chứ không phải một luồng. Điều đó tạo nên sự khác biệt gì? Goroutines có thể được điều khiển bởi Go Scheduler, hoạt động giống như một cảnh sát giao thông. Nó sử dụng lại các luồng nhàn rỗi và phân công công việc một cách thông minh, bằng cách cho phép “đánh cắp công việc” và chuyển giao công việc giữa các luồng. Điều này nghe có quen không? Đây cũng là nguyên tắc mà các bộ cân bằng tải được xây dựng dựa trên: Một màn hình bên ngoài giám sát luồng công việc giúp cải thiện hiệu suất chung. Bản thân Go về bản chất đã cân bằng tải theo cách mà nhiều ngôn ngữ lập trình không có, điều này làm cho nó trở thành nền tảng hoàn hảo cho một công cụ kiểm thử chịu tải.</p>

<p>Việc có thể tận dụng khả năng tối ưu hóa hiệu suất vốn có của Go cũng đồng nghĩa với việc sử dụng bộ nhớ ít hơn đáng kể. Một luồng chạy k6 không vượt quá 100 kb, trong khi một luồng JVM như JMeter sử dụng, chẳng hạn, sử dụng mặc định là 1MB. Đó là hơn 1000% so với k6! Tất nhiên, Java cho phép người dùng điều chỉnh mức sử dụng bộ nhớ của ứng dụng, do đó, sự khác biệt thường không quá rõ ràng, nhưng vẫn thú vị khi lưu ý rằng Go có xuất phát điểm thấp hơn nhiều.</p>

<h2 id="23-lợi-ích-về-hiệu-suất-trong-thực-tế">2.3. Lợi ích về hiệu suất trong thực tế</h2>
<h3 id="231-k6-cần-ít-load-generator-hơn">2.3.1. k6 cần ít load generator hơn</h3>
<p>Một load generator là một hệ thống mà chạy nhiều VU theo thứ tự để tạo một load trên hệ thống. Hiệu suất tương đối tốt hơn của k6 nằm ở chỗ nó cần ít load generator hơn để thực hiện một lượng tải nhất định. Kết quả chạy thực tế của hai công cụ kiểm thử k6 và JMeter có sự khác biệt đáng kể. JMeter cần tới 760MB bộ nhớ, trong khi đó, con số này là 256MB bộ nhớ ở k6.</p>

<p>Dung lượng bộ nhớ thấp hơn của k6 là lý do nó có thể chạy nhiều VU hơn và tạo ra nhiều tải hơn mức trung bình. Cho dù bạn đang sử dụng load generator tại chỗ hay trên đám mây, bạn sẽ trả ít chi phí cung cấp hơn khi sử dụng k6. Tiết kiệm chi phí này làm cho k6 trở thành một công cụ tuyệt vời cho các nhóm có ngân sách hạn hẹp.</p>

<h3 id="232-k6-xử-lý-lỗi-tràn-bộ-nhớ-out-of-memory-errors">2.3.2. k6 xử lý lỗi tràn bộ nhớ (Out of memory errors)</h3>
<p>k6 cũng là lựa chọn tốt khi bạn đang thiếu thời gian để thực hiện ca kiểm thử. Sử dụng JMeter có nghĩa là làm quen với cách điều chỉnh hiệu suất Java và cách khắc phục các sự cố hiệu suất Java phổ biến nhất, bởi vì có một số vấn đề. Cái mà gặp phải nhiều nhất khi sử dụng JMeter là chính là lỗi out of memory errors (Tràn bộ nhớ). Vấn đề này bạn sẽ không bao giờ gặp phải khi sử dụng k6.</p>

<h3 id="233-không-có-gui-có-nghĩa-là-không-cần-thêm-chi-phí-tài-nguyên-trong-quá-trình-kiểm-thử-chịu-tải">2.3.3. Không có GUI có nghĩa là không cần thêm chi phí tài nguyên trong quá trình kiểm thử chịu tải</h3>
<p>GUI thường bổ sung thêm chi phí đáng kể cho một ứng dụng, đó là một trong những lý do tại sao k6 không có. Khi bạn đang chạy kiểm tra tải, cách tốt nhất vẫn là chạy nó từ dòng lệnh, vì nếu không, nó sẽ ảnh hưởng đến kết quả của bạn. Các công cụ kiểm thử chịu tải thực hiện trên dòng lệnh có hiệu suất ngay từ đầu.</p>

<p>JMeter có rất nhiều cảnh báo về ảnh hưởng của GUI đối với hiệu suất. Đây là một từ “tài liệu JMeter”: Don’t run load test using GUI mode ! (Không chạy kiểm thử chịu tải sử dụng chế độ GUI) và đây là thông báo xuất hiện khi chạy JMeter.</p>

<p>Không có GUI nghĩa là có ít vấn đề hơn. Bất kỳ tập lệnh kiểm thử chịu tải nào bạn tạo trong k6 đều sẵn sàng để thực thi vào thời gian hợp lý nhất bất cứ khi nào bạn sẵn sàng.</p>

<h2 id="24-k6-có-thể-thực-hiện-kiểm-thử-hướng-mục-tiêu-goal-oriented-testing">2.4. k6 có thể thực hiện kiểm thử hướng mục tiêu (goal-oriented testing)</h2>
<p>Câu hỏi quan trọng nhất mà người kiểm thử chịu tải có thể đặt ra khi bắt đầu một dự án kiểm thử chịu tải mới là “Tại sao”? Các kế hoạch kiểm tra nên được thiết lập để giải quyết trực tiếp các lý do của nhóm muốn thực hiện kiểm tra chịu tải và điều đó phải được phản ánh trong các yêu cầu phi chức năng. Các yêu cầu phi chức năng sẽ đưa ra một số điều khiển về các giới hạn của hiệu suất có thể chấp nhận được. Một ví dụ phổ biến cho các giới hạn hoặc ngưỡng này là thời gian phản hồi trung bình dưới 3 giây cho tất cả các giao dịch trong quá trình thử nghiệm. k6 thực hiện điều này một cách tự nhiên với các ngưỡng cục bộ được đưa vào tập lệnh và bạn cũng có thể tạo chỉ số của riêng mình để sử dụng trong một ngưỡng. JMeter vốn không hỗ trợ các ngưỡng ở cấp độ thử nghiệm. Chúng ta phải sử dụng một số công cụ bổ sung để thực hiện công việc này như Timers, Duration Assertion, Performance Plugin,..</p>

<p>Vấn đề là mặc dù các tùy chọn này có thể thiết lập ngưỡng trong JMeter, nhưng chúng vẫn là giải pháp thay thế không đi kèm với JMeter hoặc không giải quyết thỏa đáng việc tạo các loại ngưỡng khác nhau (lỗi, thời gian phản hồi, thông lượng, CPU, bộ nhớ). Cuối cùng, mọi người thường làm là xuất dữ liệu thô từ JMeter và tự mình thực hiện phân tích bằng một công cụ khác.</p>

<p>Ngoài ra, k6 còn có một số tính năng nổi bật khác như dễ dàng hợp tác giữa người phát triển và người kiểm thử. Đây là ý tưởng ban đầu xây dựng nên công cụ kiểm thử này đã được chúng tôi phân tích trong phần ý tưởng nên tôi không phân tích rõ ở đây nữa. K6 sử dụng các tập lệnh của bạn là mã thuần túy giúp giảm bớt sự mơ hồ ở chỗ bạn không bị giới hạn bởi thiết kế giao diện người dùng kém hoặc lỗi trong các phần bổ trợ của bên thứ ba.</p>

<p>Tóm lại, qua một phép so sánh cơ bản với công cụ kiểm thử lâu đời như JMeter, chúng tôi rút ra một số trường hợp mà k6 thực hiện tốt và một số hạn chế của nó.</p>

<p>Cụ thể, k6 phù hợp cho:</p>

<ul>
  <li>Việc hợp tác giữa các thành viên trong bộ phận phát triển phần mềm giúp cho ca kiểm thử chất lượng và bao hàm được nhiều thành phần hơn khi tất cả các thành viên cùng xây dựng bối cảnh kiểm thử.</li>
  <li>Những người đang tìm kiếm một công cụ kiểm thử chịu tải nhẹ, đơn giản mà vẫn đầy đủ các tính năng<br />
Các nhóm đang tìm cách tích hợp thử nghiệm vào quy trình phát triển hiện có và quy trình CI/CD (Continuous Integration và Continuous Delivery/Deployment - quy trình kiểu mới, kết hợp tự động hoá giúp đẩy nhanh tiến độ phát triển sản phẩm và đưa sản phẩm đến người dùng cuối cùng)</li>
  <li>Đây là một công cụ mã nguồn mở, miễn phí vì vậy giúp cho đội ngũ phát triển của bạn không cần bận tâm nhiều đến các vấn đề pháp lý của phần mềm và việc mã nguồn mở nên k6 được cộng đồng người dùng đóng góp sửa đổi thường xuyên, giúp phần mềm ngày càng phát triển hoàn thiện.</li>
</ul>

<p>Và hạn chế trong một số trường hợp kể đến như:</p>

<ul>
  <li>Không có phân tích kết quả chi tiết. Người dùng cần tích hợp kết quả với cơ sở dữ liệu và phần mềm trực quan hoá dữ liệu.</li>
  <li>Không phù hợp với các nhóm kiểm thử truyền thống khi mà các nhóm này thường sử dụng các phần mềm kiểm thử có GUI trong khi k6 lại không hỗ trợ vấn đề này.</li>
  <li>K6 là một công cụ mới được phát hiện nên cộng đồng chưa được rộng lớn, phát triển như các công cụ kiểm thử lâu đời và không hỗ trợ chuyển giao với công cụ thương mại khác như LoadRunner hay NeoLoad.</li>
</ul>

<p>Các công cụ kiểm thử chịu tải bằng dòng lệnh không phải là yếu tố quan trọng nhất để cân nhắc thành công của kiểm tra tải. Biết lý do tại sao bạn đang kiểm thử, các yêu cầu là gì, hiểu và truyền đạt kết quả đều quan trọng hơn. Công cụ phù hợp sẽ cho phép bạn giải quyết những lo ngại đó trong khi cung cấp càng ít xung đột càng tốt. Không có công cụ “tốt nhất” rõ ràng; chỉ có công cụ phù hợp cho dự án và bối cảnh của bạn.</p>

<h1 id="tài-liệu-liên-quan">Tài liệu liên quan</h1>
<ul>
  <li>[1] Phạm Ngọc Hùng, Trương Anh Hoàng, Đặng Văn Hưng. <em>Giáo trình kiểm thử phần mềm</em>, 2014.</li>
  <li>[2] <em>k6 Documentation</em> <a href="https://k6.io/docs/">https://k6.io/docs/</a></li>
  <li>[3] <em>Comparing k6 and</em> JMeter for load testing <a href="https://k6.io/blog/k6-vs-jmeter/">https://k6.io/blog/k6-vs-jmeter/</a></li>
  <li>[4] <em>Jmeter</em> <a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a></li>
  <li>[5] <em>Apace Foundation</em> <a href="https://www.apache.org/">https://www.apache.org/</a></li>
  <li>[6] <em>JMeter’s Component Reference</em> <a href="https://jmeter.apache.org/usermanual/component_reference.html">https://jmeter.apache.org/usermanual/component_reference.html</a></li>
</ul>]]></content><author><name>zhao</name></author><category term="Testing" /><category term="k6" /><category term="jmeter" /><category term="testing" /><summary type="html"><![CDATA[Các công cụ kiểm thử tải (Load Testing Tool - LTT) đã trở nên rất phổ biến hiện nay, cả miễn phí và có phí, nguồn mở và nguồn đóng, và mỗi công cụ đều có điểm mạnh và yếu của riêng mình. Một số LTT được nhiều nhà phát triển sử dụng, có thể kể đến công cụ miễn phí như JMeter, Locus, fortio,… hay có tính phí như LoadNinja, Gatling,… Và Grafana k6 (hay k6) là một trong số ấy.]]></summary></entry><entry><title type="html">Bài toán sinh test cho kỹ thuật kiểm thử theo cặp - Pairwise Testing (All-Pairs Testing)</title><link href="https://zhaospei.github.io//testing/2023/03/25/two-pairs-testing/" rel="alternate" type="text/html" title="Bài toán sinh test cho kỹ thuật kiểm thử theo cặp - Pairwise Testing (All-Pairs Testing)" /><published>2023-03-25T00:00:00+07:00</published><updated>2023-03-25T00:00:00+07:00</updated><id>https://zhaospei.github.io//testing/2023/03/25/two-pairs-testing</id><content type="html" xml:base="https://zhaospei.github.io//testing/2023/03/25/two-pairs-testing/"><![CDATA[<p>Trong bài viết này, chúng ta sẽ tìm hiểu về một kỹ thuật kiểm thử tổ hợp (Combinatorial Testing) được gọi là Kiểm thử theo cặp
(Pairwise Testing hay All-Pairs Testing).</p>

<h1 id="định-nghĩa-thế-nào-là-all-pairs-testing">Định nghĩa: Thế nào là All-Pairs Testing?</h1>

<p>Theo <strong>ISTQB</strong>, <strong>All-Pairs Testing (hay Pairwise Testing)</strong> là một kỹ thuật kiểm thử hộp đen trong đó các test cases được thiết kế để thực hiện tất cả các tổ hợp có thể có của từng cặp tham số đầu vào. Tức là với mỗi cặp input đầu vào, tất cả các giá trị của cặp input đấy được phủ toàn bộ (Một test case có thể phủ được nhiều cặp input khác nhau).</p>

<p>Kỹ thuật <strong>All-Pairs</strong> rất hữu ích để thiết kế các bài kiểm tra cho các ứng dụng liên quan đến nhiều tham số. Các thử nghiệm được thiết kế sao cho đối với mỗi cặp tham số đầu vào của một hệ thống, có tất cả các tổ hợp riêng biệt có thể có của các tham số đó. Do bộ thử nghiệm bao gồm tất cả các tổ hợp nên nó không toàn diện nhưng rất hiệu quả trong việc tìm lỗi.</p>

<p>Kiểm thử <strong>All-Pairs</strong> được áp dụng phổ biến trong công nghiệp khi mà một số vấn đề chỉ được xảy ra bởi sự tương tác giữa các tham số đầu vào hoặc components. Kiểm thử <strong>All-Pairs</strong> có thể tìm được đến <strong>50 - 90%</strong> lỗi của phần mềm, hệ thống.</p>

<h1 id="số-test-cases-cần-sinh-cho-all-pairs-testing">Số test cases cần sinh cho All-Pairs Testing</h1>
<p>Ta có công thức tính số lượng test cases cần sinh như sau:</p>

<p><strong>Số lượng test case = Số lượng miền giá trị lớn nhất của các biến * Số lượng miền giá trị lớn nhất của các biến</strong></p>

<p>Chứng minh tính đúng đắn của công thức:</p>

<h1 id="cách-sinh-test-cho-all-pairs-testing">Cách sinh test cho All-Pairs Testing</h1>

<p>Chúng ta sẽ lấy ví dụ cho <strong>Ứng dụng giao dịch xe</strong> với các yêu cầu sau:</p>

<ul>
  <li>Ứng dụng giao dịch xe cho phép Mua và Bán xe.</li>
  <li>Nó sẽ hỗ trợ giao dịch ở Delhi và Mumbai.</li>
  <li>Ứng dụng phải có số đăng ký có thể hợp lệ hoặc không hợp lệ.</li>
  <li>Nó sẽ cho phép giao dịch với các hãng xe: BMW, Audi và Mercedes.</li>
  <li>Có thể thực hiện hai loại booking: E-booking và In-store.</li>
  <li>Chỉ có thể đặt xe trong giờ giao dịch.</li>
</ul>

<p>Chúng ta sẽ thực hiện việc sinh test cho ca kiểm thử <strong>All-Pairs</strong> lần lượt theo các bước sau:</p>

<h3 id="bước-1-liệt-kê-các-giá-trị-của-các-tham-số-đầu-vào">Bước 1: Liệt kê các giá trị của các tham số đầu vào.</h3>

<p>Chúng ta có thể dễ dàng liêt kê các giá trị có thể có của các tham số đầu vào của ứng dụng như sau:</p>

<ul>
  <li><strong>Loại giao dịch</strong>: Mua, Bán.</li>
  <li><strong>Vị trí</strong>: Delhi, Mumbai.</li>
  <li><strong>Hãng xe</strong>: BMW, Audi, Mercedes.</li>
  <li><strong>Số đăng ký xe</strong>: Valid (5000 giá trị), Invalid</li>
  <li><strong>Cách thức giao dịch</strong>: E-Booking, In-store</li>
  <li><strong>Thời gian giao dịch</strong>: Thời gian trong giờ làm việc, Thời gian ngoài giờ làm việc</li>
</ul>

<p>Nếu chúng ta sinh test cases cho toàn bộ các tổ hợp hợp lệ thì sẽ có đến:</p>
<ul>
  <li>2 . 2 . 3 . 5000 . 2 . 2 = <strong>24000</strong> test cases tổ hợp hợp lệ.</li>
</ul>

<p>Chưa kể chúng ta còn chưa tính đến các test cases không hợp lệ trong quá trình sinh test.</p>

<h3 id="bước-2-đơn-giản-hóa-việc-sinh-test-cases-simplify">Bước 2: Đơn giản hóa việc sinh test cases (Simplify)</h3>
<p>Chúng ta sẽ đơn giản việc sinh các test cases theo các cách:</p>
<ul>
  <li>Sử dụng một cách lẫy mẫu thông minh</li>
  <li>Sử dụng các nhóm hay ranh giới, ngay cả khi dữ liệu không rời rạc.</li>
</ul>

<p>Theo đó chúng ta có thể giảm số đăng ký xuống còn hai loại: Valid và Invaild.</p>

<p>Bây giờ, số test cases chúng ta sẽ phải sinh sẽ còn lại:</p>
<ul>
  <li>2 . 2 . 3 . 2 . 2 . 2  = <strong>96</strong> test cases.</li>
</ul>

<p>Woa Woa Woa! Chúng ta đã giảm số lượng các test case cần phải sinh một số rất lớn rồi đúng không? Nhưng đây vẫn chưa phải các sinh hợp lí để cho số lượng test cases nhỏ nhất có thể. Tiếp tục nào!</p>

<h3 id="bước-3-sắp-xếp-các-biến-theo-miền-giá-trị">Bước 3: Sắp xếp các biến theo miền giá trị</h3>

<p>Chúng ta tiến hành sắp xếp các biến theo thứ tự giảm dần số lượng miền giá trị: Tức biến có nhiều miền giá trị nhất sẽ được xếp đầu tiên  và biến có ít miền giá trị nhất được xếp cuối cùng. Sau khi sắp xếp, chúng ta sẽ có một bảng trông như thế này đây.</p>

<table>
  <thead>
    <tr>
      <th>Hãng xe</th>
      <th>Loại giao dịch</th>
      <th>Vị trí</th>
      <th>Số đăng ký xe</th>
      <th>Cách thức giao dịch</th>
      <th>Thời gian giao dịch</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="bước-4-sắp-xếp-các-miền-giá-trị-của-các-biến-để-tạo-bộ-kiểm-thử">Bước 4: Sắp xếp các miền giá trị của các biến để tạo bộ kiểm thử</h3>

<p>Chúng ta sẽ lần lượt điền giá trị của bảng trống đã tạo phía trên theo từng cột một.</p>

<table>
  <thead>
    <tr>
      <th>Hãng xe</th>
      <th>Loại giao dịch</th>
      <th>Vị trí</th>
      <th>Số đăng ký xe</th>
      <th>Cách thức giao dịch</th>
      <th>Thời gian giao dịch</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BMW</td>
      <td>Mua</td>
      <td>Delhi</td>
      <td>Valid</td>
      <td>E-booking</td>
      <td>Trong giờ</td>
    </tr>
    <tr>
      <td>Audi</td>
      <td>Bán</td>
      <td>Mumbai</td>
      <td>Invalid</td>
      <td>In-store</td>
      <td>Ngoài giờ</td>
    </tr>
    <tr>
      <td>Mercedes</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>]]></content><author><name>zhao</name></author><category term="Testing" /><category term="pairwise" /><category term="all-pairs" /><category term="testing" /><summary type="html"><![CDATA[Trong bài viết này, chúng ta sẽ tìm hiểu về một kỹ thuật kiểm thử tổ hợp (Combinatorial Testing) được gọi là Kiểm thử theo cặp (Pairwise Testing hay All-Pairs Testing).]]></summary></entry><entry><title type="html">Sử dụng SVG như một Placeholder</title><link href="https://zhaospei.github.io//op/2023/03/21/how-to-use-svg-to-show-images/" rel="alternate" type="text/html" title="Sử dụng SVG như một Placeholder" /><published>2023-03-21T00:00:00+07:00</published><updated>2023-03-21T00:00:00+07:00</updated><id>https://zhaospei.github.io//op/2023/03/21/how-to-use-svg-to-show-images</id><content type="html" xml:base="https://zhaospei.github.io//op/2023/03/21/how-to-use-svg-to-show-images/"><![CDATA[<p>Trong post này chúng ta sẽ nói về:</p>
<ul>
  <li>Tổng quan về các loại placeholder</li>
  <li>SVG-based placeholders (edges, shapes and silhouettes)</li>
  <li>Auto các process</li>
</ul>]]></content><author><name>zhao</name></author><category term="OP" /><category term="js" /><summary type="html"><![CDATA[Trong post này chúng ta sẽ nói về: Tổng quan về các loại placeholder SVG-based placeholders (edges, shapes and silhouettes) Auto các process]]></summary></entry><entry><title type="html">Chuyện chi chi rằng rằng (Phần 1)</title><link href="https://zhaospei.github.io//dummy/2023/03/20/chuyen-chi-chi/" rel="alternate" type="text/html" title="Chuyện chi chi rằng rằng (Phần 1)" /><published>2023-03-20T00:00:00+07:00</published><updated>2023-03-20T00:00:00+07:00</updated><id>https://zhaospei.github.io//dummy/2023/03/20/chuyen-chi-chi</id><content type="html" xml:base="https://zhaospei.github.io//dummy/2023/03/20/chuyen-chi-chi/"><![CDATA[<p>Bài này tớ sẽ chia sẻ về một ngày thứ bảy vô dụng của tớ khi mà tớ ngủ hơn 12 tiếng một ngày. Mục đích của bài viết này chỉ là một bài viết vui, không nhằm truyền bá tư tưởng cực đoạn, bạn đọc cân nhắc trước khi đọc để tránh ảnh hưởng tinh thần của bạn…</p>

<p>(Còn tiếp)</p>]]></content><author><name>zhao</name></author><category term="Dummy" /><category term="dummy" /><summary type="html"><![CDATA[Bài này tớ sẽ chia sẻ về một ngày thứ bảy vô dụng của tớ khi mà tớ ngủ hơn 12 tiếng một ngày. Mục đích của bài viết này chỉ là một bài viết vui, không nhằm truyền bá tư tưởng cực đoạn, bạn đọc cân nhắc trước khi đọc để tránh ảnh hưởng tinh thần của bạn…]]></summary></entry><entry><title type="html">Một số mô hình phát triển phần mềm (Phần 1)</title><link href="https://zhaospei.github.io//se/2023/02/27/software-models-chapter-1/" rel="alternate" type="text/html" title="Một số mô hình phát triển phần mềm (Phần 1)" /><published>2023-02-27T00:00:00+07:00</published><updated>2023-02-27T00:00:00+07:00</updated><id>https://zhaospei.github.io//se/2023/02/27/software-models-chapter-1</id><content type="html" xml:base="https://zhaospei.github.io//se/2023/02/27/software-models-chapter-1/"><![CDATA[<p>Mô hình phát triển phần mềm là thể hiện trừu tượng của các tiến trình phát triển phần mềm. Nó xác định các pha/ giai đoạn trong phát triển phần mềm. Trong các dự án phát triển phần mềm, mô hình đóng vai trò rất quan trọng. Mô hình đóng vai trò là hướng đi và quyết định đến chất lượng đầu ra của sản phẩm.</p>

<p>Có nhiều loại mô hình phát triển phần mềm khác nhau như:</p>
<ul>
  <li>Mô hình thác nước</li>
  <li>Mô hình xoắn ốc</li>
  <li>Mô hình tăng trưởng</li>
  <li>Mô hình Scrum
…</li>
</ul>

<p>Trong bài viết này, tôi sẽ mô tả và phân tích chi tiết bốn loại mô hình phát triển phần mềm cơ bản nhất bao gồm: Mô hình thác nước (Waterfall model), Mô hình chữ V (V-Shaped Model), Bản mẫu và Mô hình xoắn ốc.</p>

<h1 id="1-mô-hình-thác-nước">1. Mô hình thác nước</h1>
<p>Mô hình thác nước được xem là mô hình đầu tiên được giới thiệu. Đây là mô hình SDLC (Software Development Life Cycle) lâu đời với đơn giản nhất. Mô hình thác nước là mô hình điển hình cho phát triển phần mềm đảm bảo bảo tốt.</p>

<p><img src="/assets/media/post/waterfall-model.png" alt="Mô hình thác nước" /></p>

<h2 id="a-đặc-điểm">a. Đặc điểm</h2>
<p>Trong mô hình thác nước, toàn bộ quá trình phát triển phần mềm được chia thành các giai đoạn riêng biệt. Trong mô hình thác nước, thông thường, kết quả của một pha/ giai đoạn đóng vai trò là đầu vào cho pha/ giai đoạn tiếp theo.</p>

<p>Đặc điểm quan trọng nhất của mô hình thác nước là phát triển tuần tự tuyến tính (Vì vậy, nó còn có tên gọi khác là linear - sequential life cycle model). Tức trong mô hình thác nước, giai đoạn tiếp theo chỉ được bắt đầu sau khi các mục tiêu đã được xác định của giai đoạn trước được hoàn thành. Trong mô hình này, các giai đoạn phát triển một cách độc lập mà không xếp chồng lẫn nhau.</p>

<p>Tuy nhiên, trong thực tế việc thực hiện tốt một pha không phải dễ và việc xảy ra vấn đề ở là điều hiển nhiên. Vậy nếu trong quá trình phát triển gặp vấn đề có liên quan đến giai đoạn đã hoàn thành trước đó thì phải giải quyết như nào? Câu trả lời là chúng ta vẫn có thể quay lại giai đoạn trước đó sau khi đã thực hiện xong giai đoạn đấy. Tuy nhiên, sau khi quay lại, chúng ta vẫn phải tuân theo tính tuần tự của model.</p>

<h3 id="các-giai-đoạn-tuần-tự-trong-mô-hình-thác-nước">Các giai đoạn tuần tự trong mô hình thác nước</h3>
<ul>
  <li><strong>Thu thập và phân tích yêu cầu</strong>: Tất cả mọi yêu cầu có thể của hệ thống được xác định trong giai đoạn này và được ghi lại đầy đủ trong tài liệu đặc tả yêu cầu.</li>
  <li><strong>Thiết kế</strong>: Các thông số kỹ thuật trong giai đoạn đầu tiên được nghiên cứu trong giai đoạn này. Thiết kế giúp ta xác định những yêu cầu về phần cứng hệ thống, giúp ta xác định được kiến thức tổng thể của hệ thống.</li>
  <li><strong>Triển khai và kiểm thử đơn vị:</strong> Với số liệu đầu vào từ giai đoạn thiết kế, chúng ta phát triển các chương trình nhỏ gọi là Unit, sẽ được tích hợp trong giai đoạn tiếp theo. Mỗi đơn vị được triển khai và kiểm thử chức năng của nó được gọi là Unit Testing.</li>
  <li><strong>Tích hợp và kiểm thử hệ thống:</strong> Tất cả các đơn vị được thực hiện trong giai đoạn trước được tích hợp vào một hệ thống xác định. Sau khi tích hợp, toàn bộ hệ thống sẽ được kiểm tra chức năng và phi chức năng.</li>
  <li><strong>Vận hành và bảo trì:</strong>  Sản phẩm được triển khai trong môi trường của khách hàng hoặc được tung ra thị trường. Có thể có một số lỗi xảy ra trong môi trường của khách hàng, bảo trì được thực hiện để khắc phục những vấn đề trong môi trường khách hàng. Hoặc khi cần nâng cấp sản phẩm, thêm tính năng mới, bảo trì sẽ được sẽ được thực hiện.</li>
</ul>

<h2 id="b-ưu-nhược-điểm">b. Ưu, nhược điểm</h2>
<p>Mô hình thác nước được thực hiện tuần tự tuyến tính, do vậy ưu điểm lớn nhất của nó là đơn giản, dễ dàng để học và thực hiện. Mô hình đảm bảo chất lượng cao cho sản phẩm.</p>

<p>Mỗi pha của mô hình được thực hiện khi pha trước đấy đã được hoàn thiện. Vì vậy, cần làm mỗi pha phải tốt, chất lượng, khi đó mới thực hiện pha tiếp theo do nếu xảy ra lỗi việc quay lại pha trước đáy sẽ mất rất nhiều thời gian.</p>

<p>Do đó, công việc thực thiện của người phát triển nhiều hơn. Mỗi giai đoạn không chỉ thực thi mà còn viết docs và giảng giải cho những người giai đoạn tiếp theo. Dẫn đến người phát triển cần bỏ ra nhiều thời gian hơn làm cho sản phẩm thực hiện theo mô hình này thường thực hiện lâu, chi phí cao.</p>

<p>Đây là nhược điểm rõ ràng nhất của mô hình này. Bù lại, sản phẩm sẽ đảm bảo chất lượng cao do mỗi pha được thực hiện một cách hoàn chỉnh, đầy đủ, chính xác.</p>

<p>Chính vì vậy, mô hình thác nước chỉ phù hợp với các dự án vừa và nhỏ do những dự án này có thể xác định rõ yêu cầu từ đầu. Ngược lại, đối với những dự án lớn, việc xác định yêu cầu rõ ràng từ ban đầu là rất khó. Ngoài ra, việc làm tuần tự với dự án lớn là rất tốn thời gian khi mà khách hàng luôn mong muốn có sản phẩm chất lượng càng sớm càng tốt.</p>

<p>Mô hình thác nước là mô hình đầu tiên, mọi mô hình cơ bản hiện nay đều xuất phát, phát triển từ mô hình thác nước.</p>

<h1 id="2-mô-hình-chữ-v">2. Mô hình chữ V</h1>
<p>Chất lượng kiểm thử phần mềm được đánh giá qua bộ test kiểm thử và quá trình thực hiện kiểm thử. Do vậy, chất lượng của bộ test kiểm thử là rất quan trọng. Tuy nhiên, mô hình thác nước đến giai đoạn kiểm thử mới được sinh test. Việc sinh test của mô hình thác nước khiến cho khả năng phát hiện ra lỗi của bộ test rất là thấp, dẫn đến việc kiểm thử, đánh giá chất lượng phần mềm không khách quan, chính xác. Và mô hình chữ V đã được cải tiến từ thác nước để giải quyết vấn đề sinh test muộn từ mô hình thấy nước.</p>

<p><img src="/assets/media/post/v-model.png" alt="Mô hình chữ V" title="Mô hình chữ V" /></p>

<h2 id="a-đặc-điểm-1">a. Đặc điểm</h2>
<p>Cũng giống như mô hình thác nước, các giai đoạn trong mô hình chữ V được thực hiện một cách tuần tự theo hình chữ V. Tuy nhiên, cải tiến của mô hình chữ V đến từ việc sinh bộ test kiểm thử sớm bằng cách tích hợp liên kết giai đoạn kiểm thử cho từng giai đoạn phát triển tương ứng. Có nghĩa là, đối với mỗi giai đoạn trong chu kỳ phát triển sẽ có giai đoạn kiểm thử tương ứng. Mỗi giai đoạn bên trái model sẽ sinh bộ test cho giai đoạn kiểm thử bên phải của model:</p>
<ul>
  <li>Giai đoạn phân tích đặc tả yêu cầu sinh bộ test cho giai đoạn kiểm thử hệ thống, giai đoạn kiểm thử chấp nhận</li>
  <li>Giai đoạn thiết kế sinh bộ test cho giai đoạn kiểm thử tích hợp.</li>
  <li>Quá trình implementing thực hiện luôn giai đoạn kiểm thử unit.</li>
</ul>

<h2 id="b-ưu-nhược-điểm-1">b. Ưu, nhược điểm</h2>
<p>Do V Model kế thừa hầu hết từ Waterfall Model nên mọi ưu, nhược điểm đa số đều giống Waterfall Model. Tuy nhiên, ưu điểm nổi bật nhất so với Waterfall Model là giai đoạn kiểm thử được thực hiện ngay từ đầu qua công việc sinh bộ test sớm cho giai đoạn kiểm thử tương ứng nên bộ test trong V Model chính xác hơn. Nhờ vậy, việc kiểm thử được thực hiện nhanh chóng, chính xác và đánh giá phần mềm một cách khách quan nhất.</p>

<h1 id="3-bản-mẫu">3. Bản mẫu</h1>
<p>Đặc điểm của mô hình thác nước là cần xác định rõ yêu cầu từ đầu. Nhưng trong thực tế rất ít dự án xác định được rõ yêu cầu từ đầu. Vậy cần phải làm sao? Bản mẫu chính là giải pháp giải quyết vấn đề này.</p>

<h2 id="a-đặc-điểm-2">a. Đặc điểm</h2>
<p>Bản mẫu là mô hình phát triển phần mềm được phát triển dựa trên các yêu cầu của hệ thống. Dựa vào bản mẫu, khách hàng có cái nhìn tổng quan về hệ thống thực tế.</p>

<p>Bản mẫu cho phép hiểu các yêu cầu của khách hàng ở giai đoạn phát triển ban đầu ngay cả những yêu cầu khó xác định. Nhờ nhận được những phản hồi có giá trị từ khách hàng, từ đó giúp các nhà thiết kế và phát triển phần mềm hiểu chính xác những gì được mong đợi từ sản phẩm đang được phát triển.</p>

<p>Chúng ta cần dồn chi phí và nguồn lực nhiều cho làm bản mẫu, dẫn tới các công đoạn còn lại sẽ thiếu thời gian và chi phí, … Kết quả là chất lượng sản phẩm nhất là tài liệu và chất lượng code dễ có vấn đề. Ngoài ra, việc chú trọng đến bản mẫu (thường cho yêu cầu chức năng) dẫn đến dễ bỏ qua các yêu cầu phi chức năng và đa số các dự án không đạt các yêu cầu phi chức năng. Chính vì vậy, thực tế nó không được dùng phổ biến như một mô hình phát triển phần mềm. Tuy nhiên, tư tưởng của bản mẫu rất quan trọng. Nó là mấu chốt để chúng ta lôi kéo khách hàng, giải quyết những yêu cầu không được rõ ràng. Do đó, người ta thường dùng bản mẫu như là một phương pháp thu thập yêu cầu cho các mô hình khác. 
Bây giờ, người ta dùng bản mẫu như là một kỹ thuật thu thập yêu cầu.</p>

<h2 id="b-ưu-nhược-điểm-2">b. Ưu, nhược điểm</h2>
<p>Ưu điểm lớn nhất của bản mẫu giúp ta giải quyết việc xác định các yêu cầu khó của mô hình thác nước. Nhờ bản mẫu, việc xác định yêu cầu được diễn ra thuận chính xác nhờ đó việc thực hiện phần mềm dựa trên mô hình thác nước được diễn ra một cách thuận lợi. 
Bù lại, chúng ta cần chi phí cao khi sử dụng bản mẫu do cần nhiều nguồn lực cho việc làm bản mẫu. Ngoài ra, sự tham gia của khách hàng vào bản mẫu là rất quan trọng.</p>

<p>Tuy nhiên trong thực tế, việc nhiệt tình tham gia của khách hàng là khó, dẫn tới xây dựng bản mẫu khó chính xác. Từ đó, yêu cầu xác định không được rõ ràng.</p>

<p>Mặc dù vậy, chúng ta vẫn có cách làm được nhưng không phải là điều dễ dàng.</p>

<h1 id="4-xoắn-ốc">4. Xoắn ốc</h1>
<p>Mô hình thác nước, chữ V chỉ phù hợp các dự án vừa và nhỏ, những dự án được xác định rõ yêu cầu từ đầu. Việc xác định những yêu cầu khó, phức tạp đã được giải quyết nhờ bản mẫu. Tuy nhiên, trong thực tế, đa số có dự án đều lớn, phức tạp. Vậy với các dự án lớn thì giải quyết như nào? Mô hình xoắn ốc là một lựa chọn mô hình để thực hiện các dự án lớn, phức tạp.</p>

<p><img src="/assets/media/post/xoan-oc.png" alt="Mô hình xoắn ốc" /></p>
<h2 id="a-đặc-điểm-3">a. Đặc điểm</h2>

<p>Mô hình xoắn ốc là mô hình phát triển phần mềm kết hợp ý tưởng phát triển lặp đi lặp lại với các giai đoạn có hệ thống, được kiểm soát của mô hình thác nước.</p>

<p>Mô hình xoắn ốc này là sự kết hợp giữa mô hình quy trình phát triển lặp và mô hình phát triển tuyến tính tuần tự, tức là mô hình thác nước với sự nhấn mạnh rất cao vào phân tích rủi ro. Nó cho phép phát hành sản phẩm qua mỗi lần lặp xung quanh hình xoắn ốc.
Thực chất, mô hình xoắn ốc được kết hợp từ mô hình thác nước sử dụng bản mẫu để giải quyết những yêu cầu khó. Ngoài ra nó còn có quá trình phân tích rủi ro của dự án.</p>

<p>Mô hình xoắn ốc là quy trình phát triển định hướng rủi ro cho các dự án phần mềm, nghĩa là trọng tâm dự án quản lý rủi ro thông qua nhiều lần lặp lại quy trình phát triển phần mềm.</p>

<p>Mặc dù, các quá trình được lặp đi lặp lại nhưng mô hình vẫn theo tư tưởng phát triển tăng dần.</p>

<h3 id="các-giai-đoạn-trong-phát-triển-phần-mềm-theo-mô-hình-xoắn-ốc">Các giai đoạn trong phát triển phần mềm theo mô hình xoắn ốc</h3>
<ul>
  <li><strong>Planning</strong>: Lập kế hoạch, trong đó phạm vi của dự án được xác định. Một kế hoạch được tạo ra cho lần lần lặp tiếp theo của mô hình xoắn ốc.</li>
  <li><strong>Risk Analysis</strong>: Trong giai đoạn này, các rủi ro liên quan đến dự án được xác định và đánh giá.</li>
  <li><strong>Engineering</strong>: Trong giai đoạn này, phần mềm được phát triển dựa trên lần thu thập yêu cầu trước đó.</li>
  <li><strong>Evaluation</strong>: Phần mềm được đánh giá để xác định xem nó có đáp ứng các yêu cầu của khách hàng hay không và liệu nó có chất lượng cao hay không?</li>
  <li><strong>Planning</strong>: Vòng lặp tiếp theo của vòng xoắn ốc bắt đầu bằng một giai đoạn lập kế hoạch mới, dựa trên kết quả đánh giá.</li>
</ul>

<p>Trong thực tế, chúng ta không thể bê bản mẫu hay mô hình thác nước vào dự án lớn do đối với những dự án càng lớn, tỉ lệ thất bại càng cao. 
Vậy chúng ta thực hiện nó như thế nào? Chúng ta có hai chiến lược để thực hiện quá trình phát triển:</p>
<ul>
  <li><strong>Quá trình Implementing</strong></li>
</ul>

<p>Theo thống kê tính năng khách hàng sử dụng, nhận thấy có 20% tính năng bắt buộc phải có của phần mềm (core), 40 % tính năng thường xuyên được sử dụng và 40% tính năng hiếm khi sử dụng.</p>

<p>Chúng ta có thể thực hiện quá trình implementing một cách tuần tự, tức là thực hiện xong 20% tính năng bắt buộc, sau khi quá trình kiểm thử được diễn ra xong thành công, mới tiếp tục thực hiện 40% tính năng thường xuyên sử dụng. Tiếp tục với 40% tính năng hiếm khi sử dụng. 
Nhờ vậy, giúp chúng ta giảm thiểu khi thực hiện. Đây gọi là chống rủi ro.</p>

<ul>
  <li><strong>Phân tích rủi ro</strong></li>
</ul>

<p>Nhận thấy, khi chúng ta muốn xây một căn nhà cao 5 tầng, chúng ta có thể xây 3 tầng đầu tiên. Sau một thời gian, chúng ta có thể xây 2 tầng còn lại. Tuy nhiên, cái móng để xây nhà phải làm chắc có thể trụ được 5 tầng, không phải chỉ cho 3 tầng của tòa nhà được. 
Chính vì vậy, khi chúng ta thực hiện 20% tính năng core của phần mềm thì base không chỉ đủ 20% core đấy mà phải làm base cho cả hệ thống. Nhờ vậy, giảm thiểu rủi ro cho hệ thống.</p>

<p>Chúng ta, cần phải phát hiện rủi ro có thể xảy ra với dự án. Từ đó, xây dựng phương án giảm thiểu thiệt hại.</p>

<p>Tuy nhiên, mô hình xoắn ốc lại không được dùng trong thực tế do tính khả thi của phân tích rủi ro. Để phân tích được rủi ro, chúng ta cần những người có kinh nghiệm lớn, trải qua nhiều số người như này rất hiếm.
Tuy nhiên, mô hình xoắn lại có giá trị cao về học thuật.</p>

<h2 id="b-ưu-nhược-điểm-3">b. Ưu, nhược điểm</h2>
<p>Ưu điểm của mô hình xoắn ốc là nó cho phép các yếu tố, tính năng của sản phẩm được thêm vào ngay cả khi chúng đã được thực thi. Điều này đảm bảo rằng không có xung đột với các yêu cầu và thiết kế trước đó của phần mềm.</p>

<p>Mô hình xoắn ốc giải quyết được các hạn chế của mô hình thác nước. Các yêu cầu trong mô hình xoắn ốc có thể được thay đổi. Nhờ đó, các yêu cầu được xác định rõ ràng, chính xác hơn. Việc phát triển phần theo mô hình xoắn ốc giúp cho khách hàng có thể thấy toàn bộ hệ thống sớm hơn. 
Quá trình phát triển có thể được chia các phần nhỏ hơn và các phần rủi ro có thể được phát triển sớm hơn giúp quản lý rủi ro tốt hơn.</p>

<p>Tuy nhiên, việc quản lý, quy trình phát triển mô hình xoắn ốc sẽ phức tạp. Từ đó, mô hình xoắn ốc không phù hợp với các mô hình vừa và nhỏ hoặc rủi ro thấp. Ngoài ra, số lượng lớn các giai đoạn đòi hỏi cần một số lượng lớn tài liệu.</p>

<h1 id="kết-luận">Kết luận</h1>
<p>Mô hình đóng vai trò là hướng đi và quyết định đến chất lượng đầu ra của sản phẩm. Vì vậy, việc xác định đúng và chính xác mô hình cho phần mềm là rất quan trọng. Mỗi mô hình quy trình tuân theo một loạt các bước duy nhất đối với loại của nó để đảm bảo thành công trong quy trình phát triển phần mềm. Tùy vào cấu trúc phần mềm mà từ đó chọn đúng mô hình phần mềm để thực hiện. Trong thực tế, chúng ta không nhất thiết phải sử dụng đúng các mô hình phần mềm trên mà có thể “biến tấu”, thay đổi để phù hợp với dự án phần mềm.</p>]]></content><author><name>zhao</name></author><category term="SE" /><category term="software" /><category term="model" /><summary type="html"><![CDATA[Mô hình phát triển phần mềm là thể hiện trừu tượng của các tiến trình phát triển phần mềm. Nó xác định các pha/ giai đoạn trong phát triển phần mềm. Trong các dự án phát triển phần mềm, mô hình đóng vai trò rất quan trọng. Mô hình đóng vai trò là hướng đi và quyết định đến chất lượng đầu ra của sản phẩm.]]></summary></entry><entry><title type="html">Một bài giới thiệu về cái blog nho nhỏ này</title><link href="https://zhaospei.github.io//dummy/2023/02/22/about-this-blog/" rel="alternate" type="text/html" title="Một bài giới thiệu về cái blog nho nhỏ này" /><published>2023-02-22T00:00:00+07:00</published><updated>2023-02-22T00:00:00+07:00</updated><id>https://zhaospei.github.io//dummy/2023/02/22/about-this-blog</id><content type="html" xml:base="https://zhaospei.github.io//dummy/2023/02/22/about-this-blog/"><![CDATA[<p>Chào!
Hmm, đầu tiên phải giới thiệu đôi chút về bản thân nhỉ? À chắc không cần, vì mấy cái câu giới thiệu bản thân tớ 
viết đi viết lại ở hầu hết mọi trang của blog rồi… LOL.</p>

<p>Lần đầu tiên viết bài, không biết viết như nào :)). Chắc tớ sẽ nói vì sao tớ lại tạo cái blog nào và cách tớ thực hiện nó.</p>

<h2 id="tại-sao-tớ-lại-xây-dựng-cái-blog-này">Tại sao tớ lại xây dựng cái blog này?</h2>
<p>À chắc cái blog này được tạo bởi vì các ý nghĩ vớ vẩn của tớ tại một thời điểm nào đấy.
Tớ tạo blog này với mục đích ban đầu là tạo ra một chỗ lưu trữ những bài viết của tớ, nó có thể là các bài viết học thuật hay là 
những bài viết vớ vẩn chia sẻ trải nghiệm của bản thân tớ. Nhưng mục đích cuối cùng tớ muốn hướng tới là cải thiện khả năng viết
lách của bản thân và tìm một niềm vui khác khi rảnh.</p>

<h2 id="cách-tớ-thực-hiện-cái-blog-này">Cách tớ thực hiện cái blog này…</h2>
<p>Ban đầu, tớ định dùng <strong>Django</strong> để xây dựng blog nhưng nghĩ lại là dùng <strong>Django</strong> thì host kiểu gì vì tớ không có tiền để duy trì hosting. Tớ cũng đã nghĩ đến các hosting free nhưng mà nó khá là ba chấm và deloy <strong>Django</strong> rất rườm rà. Và rồi, tớ nghĩ sao tớ 
không dùng chính <strong>Github Pages</strong> để host nhỉ? Cuối cùng, tớ đã quyết định dùng nó để host và sử dụng <strong>jekyll</strong> để xây dựng blog. 
Và rồi, tớ đã bắt tay vào làm nó…</p>

<p>Về giao diện của blog, tớ lấy cảm hứng từ <a href="https://reaganhenke.com/">Reaganhenke</a> và <a href="https://www.digitalocean.com/">Digital Ocean</a>.</p>

<p>Tớ biết đến <a href="https://reaganhenke.com/">Reaganhenke</a> nhờ vào một hôm tìm cái trang web nghe nhạc lofi để học. Sau khi tìm hiểu, tớ có biết đến <a href="https://imissmycafe.com/">I Miss My Cafe</a>. Đây là một trang đối với tớ khá là hay, recommend cậu trang này nhé!(à cậu có thể vào để tìm hiểu về nó nhé :))). Tính tớ hay tò mò nên tớ đã lục lọi để tìm ra source của nó để clone lại một trang giống như vậy :)). Kết quả là tớ chỉ tìm được page của người làm ra nó. Và rồi, tớ bị thu hút bởi thiết kế của page, nhất là mấy cái card đầu của page. Haha, và rồi tớ lấy nó để làm giao diện.
 <em>(Reagan Henke, if you see this blog, please forgive me for using it without your permission!)</em>.</p>

<p>Còn <a href="https://www.digitalocean.com/">Digital Ocean</a> thì một lần tớ tìm tutorial và tìm ra nó. Đây cũng một trang chất lượng, recommend cậu trang này nữa nhé! (À thực ra ai cũng biết đến trang này :))).</p>

<p>Ngoài ra tớ còn sử dụng <a href="https://vincentgarreau.com/particles.js/">particles.js</a> để làm mấy cái lines nối nhau trông rườm rà ở background và <a href="https://talk.hyvor.com/">Hyvor</a> để làm phần comment (Tớ chỉ được dùng thử 15 ngày nên không biết 15 ngày sau nó có bị mất không :))).</p>

<h2 id="mục-đích-hướng-đến-của-blog">Mục đích hướng đến của blog…</h2>
<p>Blog này tớ dự định sẽ là chia sẻ những bài viết, chủ đề mà tớ tìm hiểu và nghiên cứu. Hiện tại, tớ đang theo Lab CNPM nên đa số bài viết sẽ liên quan đến chủ đề này. Nếu cậu cũng đang tìm hiểu về chủ đề này thì có thể đọc blog của tớ nhé để giúp tớ cản thiện bài viết của bản thân. Ngoài ra, tớ cũng đang tìm hiểu về AI/ML nữa. Cũng có thể sẽ là những bài viết chia sẻ những trải nghiệm của bản thân. Nhưng mà tớ rất là lười viết nên có thể rất lâu tớ mới viết một bài mới _D:.</p>

<p>Cậu cũng có thể gửi bài tới blog nhé. Rất là khuyến khích ủng hộ luôn.</p>

<h2 id="mong-muốn-của-tớ">Mong muốn của tớ…</h2>
<p>Tớ tạo blog vì ý nghĩ nhất thời và mục đích cá nhân là nhiều nên tớ cũng không mong blog sẽ được biết đến rộng rãi. À được nhiều người biết thì cũng không sao. Mong rằng với những người biết đến blog của tớ sẽ nhận được điều gì đó mới mẻ khi đọc những bài viết vớ vẩn của tớ. Vậy thôi…</p>

<p>Cậu có thể xem source code của blog tớ tại <a href="https://github.com/zhaospei/zhaospei.github.io">Github</a>.</p>

<p>Cảm ơn cậu đã ghé thăm blog của tớ và đọc cái post mở đầu xàm này. 
Nếu có gì góp ý cho blog thì cậu comment phía dưới nhé, tớ sẽ sớm khắc phục. (À comment sớm nhé chứ phần comment chỉ được dùng thử 15 ngày :)).</p>

<p><br /></p>
<div style="text-align: right"> 
See yaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
</div>

<div style="text-align: right"> 
<strong>Zhao</strong>
</div>]]></content><author><name>zhao</name></author><category term="Dummy" /><category term="doc" /><category term="talk" /><category term="zhao" /><summary type="html"><![CDATA[Chào! Hmm, đầu tiên phải giới thiệu đôi chút về bản thân nhỉ? À chắc không cần, vì mấy cái câu giới thiệu bản thân tớ viết đi viết lại ở hầu hết mọi trang của blog rồi… LOL.]]></summary></entry></feed>